**伤害信息（DamageInfo）**

之所以把这个放在第一位说，是因为这通常是一个完全会被忽略的信息，并且当你忽略了这个信息的时候，你的游戏整个伤害流程都是别扭的。“伤害不就是一个数字吗？”从表面现象来看，似乎是这样，那为什么我们需要加入这么一个多余的Info呢？因为它在实际的游戏逻辑运作中，起到了非常重要的承上启下的作用：

首先，DamageInfo是贯穿整个伤害处理流程的，一个伤害处理流程通常是这样的：
![[造成伤害的流程.png]]


从流程可以看到，在这个流程的过程中，我们通过buff的不同触发点的事件执行各种效果的同时，不断改写这个DamageInfo，最终产生出一个最后的伤害信息用于做最后的处理，这里需要一提的是——不是说跳数字就是伤害处理的流程，伤害处理流程可不管跳数字，跳数字是UI的事情，UI需要怎么跳数字、跳什么数字，是UI规则，buff可以调用比如PopNumber之类的接口来跳数字，但是伤害流程是不干这个的，除非游戏设定了处理伤害的流程里，一定会按照一个规则跳数字，这也是允许的，但这明显是伤害流程的side-effect。

除了正常逻辑之外，任何伤害都应该走DamageInfo，这也是有原因的，正如上面流程所示，我们现在来假象一个情况——攻击者A有一个被动技能，是攻击的时候额外附带3下伤害，因此一共4个伤害，比如分别是5、10、15、20点伤害；而受击者D，身上有一个被动技能：受到>0点的伤害时，下一次受到伤害为0。这样一个设计之下，就会出现一个有意思的事情，假如我们不创建DamageInfo并且丢进一个管理器里面，那么在走到攻击者A所有onHit的buff的时候，就会直接产生下一次伤害，这时候流程还没走到D的Buff.beHurt，也就是说，D的被动效果没有发生，下一个伤害已经出来了，最终，在D受到最后一下20点伤害之后，第三下的15点化为0了，然后受到了第二下的10点，之后第一下的5点被划为0了，这肯定不是应有的效果，但是程序执行的循环就是这么走的。于是我们需要让“额外的3次伤害”产生3个DamageInfo，丢在一个管理器里，管理器while do来挨个按顺序执行所有的DamageInfo，由此效果就正确了。

从设计角度上来说，DamageInfo还解决了一个经典的争议——暴击了必定命中，还是命中了才会暴击——因为在DamageInfo中记录了是否会命中，和是否会暴击，这两个是等价并行的，没有先后问题，直到最后策划再来做决策，是命中了才暴击，还是暴击必定命中，我们可以看一下DamageInfo的具体属性：

- attacker：攻击者的GameObject，也就是发起这次伤害信息的攻击者，这个攻击者当然可以是空的，因为并不是所有的伤害都是人为造成的，比如说我们走到关卡中某个地刺上的时候，攻击者并不是一个角色，这时候Attacker应该是空。
- defender：受到伤害的角色的GameObject，这个角色必须是存在的，如果是空，那么这条伤害信息就没有任何意义了。同样的，根据游戏的设定，大多游戏中Defender如果已经挂了，也一样会把这条数据销毁了（因为通常游戏都不具有鞭尸的功能，但这并不代表你想做的时候不能做）。
- tags：字符串数组，伤害类型的tag，这在buff的脚本逻辑中会是一个非常重要的元素。这里是策划的游戏设计中必须定义清楚的东西，它是用来描述一个伤害的类型的，这个类型并不是说比如“冰冻伤害”、“火焰伤害”之类的不同的属性伤害的，而是用来描述“伤害源”类似的东西的，比如是“直接伤害”、“间歇伤害”、“反弹伤害”等等，这些定义都是因游戏而已的，并不是一个固定的范式。比如当我们要做一个buff，这个buff的效果是“反弹受到的伤害给攻击者”，如果攻防双方（设为A和B两个角色）身上都有这个buff，就会发生：A对B产生伤害，之后B的buff反弹伤害给A形成B对A造成伤害，这时候A的Buff又生效了，反弹给B，这样会发生一个“短路”现象，直到A或者B有一方作为defender的时候被击败了，循环才会终止。所以此时，我们需要根据DamageInfo的tag来判断，这个伤害对于这个buff来说该不该发生反弹，由此避免类似的死循环问题。而除此之外，我们还会遇到很多类似“受到直接伤害的时候伤害降低最多50点”之类的效果，都是需要通过tag来判断这次伤害的类型的。。

- **damage**：一个伤害数据结构，这是根据游戏不同来设计的，比如游戏中有金木水火土外加物理攻击，那么他就应该是有6个伤害数字组成的。我们通常忽略的一种情况是——策划会设计一些针对游戏中“元素属性”类似的东西有效的效果，比如“受到的火焰伤害减半”，如果此时受到的攻击是一个“暗影烈焰”，即暗属性伤害200点+火属性伤害200点，那么就得从这里面去找到暗影属性伤害减去一半；再比如“短时间内抑制所有受到的子弹伤害”，那么这个伤害的数据里面有一条肯定是子弹伤害，将子弹伤害设定为0，就抑制了。
- **damageDegree**：伤害的角度，也就是伤害打向defender的入射角度，通常这个角度来源是取子子弹的飞行方向或者aoe的中心点指向角色的位置的。这个角度配合角色当前的面向角度，就可以算出角色什么方向受到了伤害，假如需要做类似“背刺”的效果，那就得用上这个了。
- **criticalRate**：本次攻击的最终暴击率，大多游戏还是有暴击设计的，如果没有，可以砍掉这个数据。当一次伤害信息经历了所有流程之后，将最后的数值传递给策划编写的公式脚本，由策划来处理是否暴击了，以及暴击造成多少伤害。
- **hitRate**：和暴击率类似的概念，但是他俩在逻辑流程中实际上并无直接关系，即当有一个效果是“下一次攻击必定暴击”，这时候的DamageInfo哪怕hitRate是<=0的数字，也不妨碍criticalRate被设置为1或者更高的数字（假如策划认为1代表100%，这完全是由设计数值公式的策划来定义的），这两者并无依赖关系，不是说不命中就一定不能暴击，最后不命中能不能暴击，暴击了是不是一定命中，还是看策划写的公式脚本如何认为。
- **addBuffs**：这是一个“隐藏属性”，所以在上述结构中并没有标明，但是非常有必要说明一下。因为在整个伤害的流程中，我们可能因为一些角色身上的buff效果，他会需要添加新的buff效果，而这个新的buff效果并不想马上添加给角色（通常都是如此），比如说攻击者有一个buffA，他的效果是“攻击后目标受到割裂影响”，也就是在目标身上上一个buffB；还有一个优先级更低（更晚执行）的buffC，是“对割裂的目标造成的伤害提高200%”，策划设计的时候的想法是，这次攻击造成割裂，下次才是3倍伤害，但是因为执行顺序，产生了本次就直接上了割裂并且3倍伤害，我们不能让策划因为这个去调整buff的优先级，因为这会导致逻辑混乱，优先级本身是期望某些必然又先后关系的buff之间用的，这种其实对于策划设计的思路来说，是“非必然的先后顺序”，因此理论上来说，策划完全可以用buff的priority来解决这个问题，但这属于设计burden，因此我们通过在DamageInfo中添加这么一个List，把在流程中的这些AddBuffInfo储存在这里，在完成流程后执行，而策划要做的，则是在BuffOnHit、BuffBeHurt、BuffOnKill、BuffBeKilled中产生的buff（这些概念都会在下文中详细说明），通过

public void AddBuffToCha(AddBuffInfo buffInfo)

来添加给这个damageInfo

值得一提的是，这是一个目前demo中用到的damageInfo的结构，这并不代表每一个游戏的damageInfo都是长这样的，具体还是得由设计游戏内容的策划，来定义一次攻击到底是个什么样的事情，具体的事情——我们通常会认为“一次攻击”还不好理解吗？但实际上确实不好理解，因为“一次攻击”只是一个概括，什么都是也什么都不是，在我们实际开发工作中，定义好DamageInfo和DamageManager（也就是伤害流程），才是完整的游戏伤害系统设计。